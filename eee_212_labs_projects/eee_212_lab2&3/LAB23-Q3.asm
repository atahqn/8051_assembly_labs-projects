	ORG 0
	ACALL CONFIGURE_LCD
	MOV R1,#48H
	MOV R0,#40H
	MOV A,#01011000B
	MOV @R0,A
	INC R0
	MOV A,#10010110B
	MOV @R0,A
	MOV R5,#5
BEGIN2:	MOV R2,#8 ;FOR MAKING 8 RANDOM BITS
BEGIN:	MOV A,@R0
	RRC A	;BIT 16 IS IN CARRY
	MOV 20H,C

	CLR A
	XCH A,B
	CLR A
	CLR C
	MOV A,@R0
;	JC ONE
;	SJMP ZERO
;	ONE: MOV R7,#1
;	RLC A
;	SJMP NEXT
;	ZERO: MOV R7,#0
;	RLC A
;	NEXT: ;PUSH ACC
;	MOV A,7
;	RR A
;	MOV 7,A
;	POP ACC 
	ANL A,#00101101B ; WE JUST NEED BITS 11-13-14-16 
	RRC A		; 12-14-15
	PUSH ACC
	CLR A
	ADDC A,#0	;ADDING C TO A
	XCH A,B		;MOVING C TO B NOW WE HAVE BIT 16 IN B REGISTER
	POP ACC		; NOW WE FIND BIT 14
	RRC A		; 13-15-16
	RRC A		; 14-16------CARRY IS BIT 14
	PUSH ACC
	CLR A
	ADDC A,#0	;MOVING C TO A
	XRL A,B		; 16 XOR 14
	XCH A,B		;MOVING RESULT OF 16 XOR 14 TO B REGISTER
	POP ACC		;14-16
	RRC A		; 15----- BIT 13 IS IN CARRY
	PUSH ACC
	CLR A
	ADDC A,#0	;MOVING CARRY TO A
	XRL A,B		; NOW WE HAVE (16 XOR 14)XOR 13)
	XCH A,B		; WE MOVE RESULT TO B REGISTER
	POP ACC		; 15
	RRC A		; 16 WE DONT NEED TO DO MORE BECAUSE WE HAVE ONLY 1 BIT
	XRL A,B		; RESULT OF XOR'S AT REGISTER A
	MOV R3,A	; OUTPUT OF (((16 XOR 14) XOR 13) XOR 11) STORED IN R3
	XCH A,B
	CLR A
	XCH A,B
	CLR A
	CLR C
	

	
	DEC R0		;GO BACK TO 40H
	MOV A,@R0	;GET VALUE AT 40H
	RRC A		;ROTATING FIRST 8 BIT TO RIGHT
	MOV B.0,C	;BIT 8 IS IN B.O
	RLC  A
	PUSH ACC
	
	MOV A,R3
	RRC A		;GETTING RESULT TO CARRY
	POP ACC
	RRC A
	MOV @R0,A
	INC R0		;NOW WE ARE IN 41H
	MOV A,@R0
	MOV C,B.0
	RRC A
	MOV @R0,A

	
	MOV A,24H
	MOV B,6
	ADD A,B
	RR A
	MOV 6,A

	DJNZ R2,BEGIN
	MOV @R1,6
	MOV R6,#0
	INC R1
	DJNZ R5,BEGIN2
;HERE:	SJMP HERE

;NOW WE HAVE OUR RANDOM NUMBERS
;WE NEED TO SHOW THEM IN THE SCREEN IN ONE SECOND DELAY
;MOV R4,#5	;FIVE NUMBER FIVE TIMES
CLR C
CLR A
MOV R1,#48H
	MOV A,@R1
ACALL HEX_TO_ASCII
MOV A,#02DH
ACALL SEND_DATA
ACALL DELAY1SECOND
INC R1
	MOV A,@R1
ACALL HEX_TO_ASCII
MOV A,#02DH
ACALL SEND_DATA
ACALL DELAY1SECOND
INC R1
	MOV A,@R1
ACALL HEX_TO_ASCII
MOV A,#02DH
ACALL SEND_DATA
ACALL DELAY1SECOND
INC R1
	MOV A,@R1
ACALL HEX_TO_ASCII
MOV A,#02DH
ACALL SEND_DATA
ACALL DELAY1SECOND
MOV A, #0C0H
ACALL SEND_COMMAND
INC R1
	MOV A,@R1
ACALL HEX_TO_ASCII

HERE:SJMP HERE
DELAY1SECOND:
MOV R7,#100

DELAY1MSECOND:
	MOV TMOD,#01H ; TIMER 0 , MODE 1
	MOV TH0, #0D8H 
	MOV TL0, #0F0H
	SETB TR0
AGAIN:  JNB TF0, AGAIN
	CLR TR0
	CLR TF0
DJNZ R7,DELAY1MSECOND
RET

FINITO:SJMP FINITO






HEX_TO_ASCII:CJNE A,#100,$+3
	JC LESSTHAN100
	MOV B,#10
	DIV AB
	MOV R7,B; ONES
	MOV B,#10
	DIV AB
	MOV R6,B;TENS
	MOV R5,A;HUNDREDS
	MOV A,R5
	ADD A,#30H
	ACALL SEND_DATA
	MOV A,R6
	ADD A,#30H
	ACALL SEND_DATA
	MOV A,R7
	ADD A,#30H
	ACALL SEND_DATA
	RET
LESSTHAN100:CJNE A,#10,$+3
	JC LESSTHAN10
	MOV B,#10
	DIV AB
	MOV R6,A;TENS
	MOV R7,B;ONES
	MOV A,R6
	ADD A,#30H
	ACALL SEND_DATA
	MOV A,R7
	ADD A,#30H
	ACALL SEND_DATA
	RET
LESSTHAN10:
	MOV R7,A;ONES
	MOV A,R7
	ADD A,#30H
	ACALL SEND_DATA
	RET

CONFIGURE_LCD:	;THIS SUBROUTINE SENDS THE INITIALIZATION COMMANDS TO THE LCD
	mov a,#38H	;TWO LINES, 5X7 MATRIX
	acall SEND_COMMAND
	mov a,#0FH	;DISPLAY ON, CURSOR BLINKING
	acall SEND_COMMAND
	mov a,#06H	;INCREMENT CURSOR (SHIFT CURSOR TO RIGHT)
	acall SEND_COMMAND
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	mov a,#80H	;FORCE CURSOR TO BEGINNING OF THE FIRST LINE
	;acall SEND_COMMAND
	ret


SEND_COMMAND:
	mov p1,a		;THE COMMAND IS STORED IN A, SEND IT TO LCD
	clr p3.5		;RS=0 BEFORE SENDING COMMAND
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


SEND_DATA:
	mov p1,a		;SEND THE DATA STORED IN A TO LCD
	setb p3.5	;RS=1 BEFORE SENDING DATA
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


DELAY:
	push 0
	push 1
	mov r0,#50
DELAY_OUTER_LOOP:
	mov r1,#255
	djnz r1,$
	djnz r0,DELAY_OUTER_LOOP
	pop 1
	pop 0
	ret


KEYBOARD: ;takes the key pressed from the keyboard and puts it to A
	mov	P0, #0ffh	;makes P0 input
K1:
	mov	P2, #0	;ground all rows
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, K1
K2:
	acall	DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER
	sjmp	K2
KB_OVER:
	acall DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER1
	sjmp	K2
KB_OVER1:
	mov	P2, #11111110B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_0
	mov	P2, #11111101B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_1
	mov	P2, #11111011B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_2
	mov	P2, #11110111B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_3
	ljmp	K2
	
ROW_0:
	mov	DPTR, #KCODE0
	sjmp	KB_FIND
ROW_1:
	mov	DPTR, #KCODE1
	sjmp	KB_FIND
ROW_2:
	mov	DPTR, #KCODE2
	sjmp	KB_FIND
ROW_3:
	mov	DPTR, #KCODE3
KB_FIND:
	rrc	A
	jnc	KB_MATCH
	inc	DPTR
	sjmp	KB_FIND
KB_MATCH:
	clr	A
	movc	A, @A+DPTR; get ASCII code from the table 
	ret

;ASCII look-up table 
KCODE0:	DB	'1', '2', '3', 'A'
KCODE1:	DB	'4', '5', '6', 'B'
KCODE2:	DB	'7', '8', '9', 'C'
KCODE3:	DB	'*', '0', '#', 'D'


END


