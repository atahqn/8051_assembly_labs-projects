BACK:		ACALL CONFIGURE_LCD
		ACALL KEYBOARD
		ACALL SEND_DATA
NEW_INPUT:	SUBB A,#30H
		MOV B, #10
		MUL AB
		MOV R0,A
		
		ACALL KEYBOARD
		ACALL SEND_DATA
		
		SUBB A,#30H
		ADD A,R0
		PUSH ACC ; STORE FIRST DECIMAL INPUT INCASE EQUAL TO ZERO
		MOV R0,A
		MOV A,#7CH; SYMBOL OF |
		ACALL SEND_DATA
		
		ACALL KEYBOARD
		ACALL SEND_DATA
		
		SUBB A,#30H
		MOV B, #10
		MUL AB
		MOV R7,A
		
		ACALL KEYBOARD
		ACALL SEND_DATA
		
		SUBB A,#30H
		ADD A,R7
		MOV R7,A
;		MOV A,R6 ;STORE THE SECOND DECIMAL VALUE
		MOV B,R0
		DIV AB
;		MOV R5,B
		MOV A,#20H ; SPACE CHARACTER
		ACALL SEND_DATA
		MOV A,#3FH ; QUESTION MARK SYMBOL ?
		ACALL SEND_DATA 
		
AGAIN1:		ACALL KEYBOARD
		CJNE A,#44H,AGAIN1 ; TAKE INPUT UNTIL INPUT IS D(44H)
;		SJMP SKIP1
		MOV R5,B	
		POP ACC		; BEFORE DECIDING TRUE OR FALSE LETS LOOK AT WHETHER X IS 0 OR NOT
		JZ NOT_DIVBLE	; IF Y == 0 GO TO NOT_DIVBLE
;SKIP1:		
		
;		POP ACC		; BEFORE DECIDING TRUE OR FALSE LETS LOOK AT WHETHER X IS 0 OR NOT
;		CJNE A,6,$+3
;		JC NOT_DIVBLE	; IF X>Y GO TO NOT_DIVBLE
;		JZ NOT_DIVBLE	; IF Y == 0 GO TO NOT_DIVBLE

		CJNE R5,#00,NOT_DIVBLE
;		SJMP DIVBLE
;NOT_DIVBLE:    	CPL P3.0
;		MOV A,#0C0H
;		ACALL SEND_COMMAND
;		MOV A,#46H			;F=46H
;		ACALL SEND_DATA	
;		MOV A,#41H			;A=41H
;		ACALL SEND_DATA				
;		MOV A,#4CH			;L=4CH
;		ACALL SEND_DATA			
;		MOV A,#53H			;S=53H
;		ACALL SEND_DATA		
;		MOV A,#45H			;E=45H
;		ACALL SEND_DATA
;		ACALL KEYBOARD
;		PUSH ACC
;		ACALL CONFIGURE_LCD
;		POP ACC
;		ACALL SEND_DATA			
;		LJMP  NEW_INPUT			;GO BACK

DIVBLE:		SETB P3.0
		MOV A,#0C0H
		ACALL SEND_COMMAND
		MOV A,#54H			;T=54H
		ACALL SEND_DATA
		MOV A,#52H			;R=52H
		ACALL SEND_DATA		
		MOV A,#55H			;U=55H
		ACALL SEND_DATA		
		MOV A,#45H			;E=45H
		ACALL SEND_DATA
		ACALL KEYBOARD
		PUSH ACC
		ACALL CONFIGURE_LCD
		POP ACC
		ACALL SEND_DATA
		LJMP  NEW_INPUT			;GO BACK
NOT_DIVBLE:    	CPL P3.0
		MOV A,#0C0H
		ACALL SEND_COMMAND
		MOV A,#46H			;F=46H
		ACALL SEND_DATA	
		MOV A,#41H			;A=41H
		ACALL SEND_DATA				
		MOV A,#4CH			;L=4CH
		ACALL SEND_DATA			
		MOV A,#53H			;S=53H
		ACALL SEND_DATA		
		MOV A,#45H			;E=45H
		ACALL SEND_DATA
		ACALL KEYBOARD
		PUSH ACC
		ACALL CONFIGURE_LCD
		POP ACC
		ACALL SEND_DATA			
		LJMP  NEW_INPUT			;GO BACK	

KEYBOARD_LOOP:
	acall KEYBOARD
	;now, A has the key pressed
	acall SEND_DATA
	sjmp KEYBOARD_LOOP




CONFIGURE_LCD:	;THIS SUBROUTINE SENDS THE INITIALIZATION COMMANDS TO THE LCD
	mov a,#38H	;TWO LINES, 5X7 MATRIX
	acall SEND_COMMAND
	mov a,#0FH	;DISPLAY ON, CURSOR BLINKING
	acall SEND_COMMAND
	mov a,#06H	;INCREMENT CURSOR (SHIFT CURSOR TO RIGHT)
	acall SEND_COMMAND
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	mov a,#80H	;FORCE CURSOR TO BEGINNING OF THE FIRST LINE
	acall SEND_COMMAND
	ret



SEND_COMMAND:
	mov p1,a		;THE COMMAND IS STORED IN A, SEND IT TO LCD
	clr p3.5		;RS=0 BEFORE SENDING COMMAND
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


SEND_DATA:
	mov p1,a		;SEND THE DATA STORED IN A TO LCD
	setb p3.5	;RS=1 BEFORE SENDING DATA
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


DELAY:
	push 0
	push 1
	mov r0,#50
DELAY_OUTER_LOOP:
	mov r1,#255
	djnz r1,$
	djnz r0,DELAY_OUTER_LOOP
	pop 1
	pop 0
	ret


KEYBOARD: ;takes the key pressed from the keyboard and puts it to A
	mov	P0, #0ffh	;makes P0 input
K1:
	mov	P2, #0	;ground all rows
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, K1
K2:
	acall	DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER
	sjmp	K2
KB_OVER:
	acall DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER1
	sjmp	K2
KB_OVER1:
	mov	P2, #11111110B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_0
	mov	P2, #11111101B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_1
	mov	P2, #11111011B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_2
	mov	P2, #11110111B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_3
	ljmp	K2
	
ROW_0:
	mov	DPTR, #KCODE0
	sjmp	KB_FIND
ROW_1:
	mov	DPTR, #KCODE1
	sjmp	KB_FIND
ROW_2:
	mov	DPTR, #KCODE2
	sjmp	KB_FIND
ROW_3:
	mov	DPTR, #KCODE3
KB_FIND:
	rrc	A
	jnc	KB_MATCH
	inc	DPTR
	sjmp	KB_FIND
KB_MATCH:
	clr	A
	movc	A, @A+DPTR; get ASCII code from the table 
	ret

;ASCII look-up table 
KCODE0:	DB	'1', '2', '3', 'A'
KCODE1:	DB	'4', '5', '6', 'B'
KCODE2:	DB	'7', '8', '9', 'C'
KCODE3:	DB	'*', '0', '#', 'D'

END